#include "/Engine/Private/Common.ush"
#include "/Engine/Private/ScreenPass.ush"

Texture2D InputDepthTexture;
SamplerState InputDepthSampler;

float2 InputViewMin;
float2 SourceViewSize;
float2 InvSourceViewSize;
float2 DestViewSize;
float2 SourceToDestScale;
float2 InputTextureSize;

static const float2 Epsilon2 = float2(1e-6f, 1e-6f);

float2 ComputeViewportUV(float2 InputUV)
{
	float2 absolutePixel = InputUV * InputTextureSize;
	float2 viewportPixel = absolutePixel - InputViewMin;
	return viewportPixel * InvSourceViewSize;
}

float2 ConvertVelocityToDestScreen(float2 VelocityNDC)
{
	float2 safeDestSize = max(DestViewSize, float2(1.0f, 1.0f));
	float2 velocityPixelsSource = VelocityNDC * SourceViewSize * 0.5f;
	float2 velocityPixelsDest = velocityPixelsSource * SourceToDestScale;
	return velocityPixelsDest * (2.0f / safeDestSize);
}

// 数据集故意不加 object motion, 所以未采样 SceneVelocity
float4 MainPS(FScreenVertexOutput In) : SV_Target0
{
	float deviceZ01 = InputDepthTexture.SampleLevel(InputDepthSampler, In.UV, 0.0f).r;

    // 把基于整张纹理的 In.UV 转化成 viewport 归一化坐标(考虑了左上角可能有个非零的 ViewRect.Min)
	float2 viewportUV = ComputeViewportUV(In.UV);

    // viewportUV [0, 1] -> screenPos [-1, 1], UE 的 screen pos 其实指的是 x, y 的 NDC
	float2 screenPos = ViewportUVToScreenPos(viewportUV);

	float4 prevClip = mul(float4(screenPos, deviceZ01, 1.0f), View.ClipToPrevClip);
	float denom = max(prevClip.w, 1e-6f);
	float2 prevScreen = prevClip.xy / denom;

    // 历史帧指向当前帧, 方向不同于 TAA 常用的移动矢量, 范围 [-2, 2]
	float2 velocityNDC = screenPos - prevScreen;

    // 以上计算以 source view 为基准, 因为外部只能传入以此为基准的 View.ViewUniformBuffer,
    // 这里把 velocity 转换成以 dest view 为基准, 范围 [-2, 2]
	float2 velocityDest = ConvertVelocityToDestScreen(velocityNDC);

    // UE 的屏幕坐标, 左下角为(-1, -1), 右上角为(1, 1), 因此移动向上为则正,向下则为负, HLSL 利用UV采样时需要翻转.
    // [-2, 2] -> SNORM [-1, 1]
	return float4(velocityDest * 0.5f, 0.0f, 0.0f);
}
