#include "/Engine/Private/Common.ush"
#include "/Engine/Private/ScreenPass.ush"

Texture2D InputDepthTexture;
SamplerState InputDepthSampler;
Texture2D InputVelocityTexture;
SamplerState InputVelocitySampler;

float2 ComputeStaticVelocity(float2 screenPos, float deviceZ01)
{
	float3 posN = float3(screenPos, deviceZ01);
	float4 thisClip = float4(posN, 1);

	// 依赖 C++ 侧传入 View.ViewUniformBuffer
	float4 prevClip = mul(thisClip, View.ClipToPrevClip); 
	float2 prevScreen = prevClip.xy / prevClip.w;

	// 历史帧指向当前帧, 方向不同于 TAA 常用的移动矢量.
	// 因为 screenPos 范围 [-1, 1], 所以输出范围 [-2, 2]
	return posN.xy - prevScreen;
}

// 数据集故意不加 object motion, 所以未采样 SceneVelocity
float4 MainPS(FScreenVertexOutput In) : SV_Target0
{
	float2 velocity = 0;
	//float4 encodedVelocity = InputVelocityTexture.SampleLevel(InputVelocitySampler, In.UV, 0.0f);
	//if (encodedVelocity.x > 0.0 )
	//{
	//	velocity = DecodeVelocityFromTexture(encodedVelocity).xy;
	//}
	//else
	//{
		// 已知 InputViewport 和 OutputViewRect 是相等的, 可用 dest UV 去采样 source, 
		// 无论两者输入输出 RenderTarget 是否相同, 都可以这样做, UE 内部会转化.
		float deviceZ01 = InputDepthTexture.SampleLevel(InputDepthSampler, In.UV, 0.0f).r;

		// [0, 1] -> screenPos [-1, 1], UE 的 screen pos 其实指的是 NDC xy
		float2 screenPos = ViewportUVToScreenPos(In.UV);

		velocity = ComputeStaticVelocity(screenPos, deviceZ01).xy;
	//}

    // UE 的屏幕坐标, 左下角为(-1, -1), 右上角为(1, 1), 因此移动向上为则正,向下则为负.
	// 而在 UV 空间计算或利用常见的 warp 操作, 一般向下移动为正, 需将 Y 翻转.
    // 这里把 [-2, 2] -> [-1, 1] 以及 Y 翻转合并, 注意移动矢量是历史帧指向当前帧
	return float4(velocity * float2(0.5f, -0.5f), 0.0f, 0.0f);
}
